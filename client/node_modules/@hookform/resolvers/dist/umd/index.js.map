{"version":3,"file":"index.js","sources":["../../node_modules/superstruct/lib/index.es.js","../../src/utils/convertArrayToPathName.ts","../../src/superstruct.ts","../../src/joi.ts","../../src/zod.ts","../../src/vest.ts","../../src/yup.ts"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction* run(value, struct, options = {}) {\n  const {\n    path = [],\n    branch = [value],\n    coerce = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n\nfunction assign(...Structs) {\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n\n    *entries(value, ctx) {\n      var _struct;\n\n      (_struct = struct) != null ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    }\n\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  return define('literal', value => {\n    return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n\n    coercer(value) {\n      return isObject(value) ? { ...value\n      } : value;\n    }\n\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(struct, fallback, options = {}) {\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to mask its input to only properties defined in the struct.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction masked(struct) {\n  return coerce(struct, unknown(), x => {\n    if (typeof struct.schema !== 'object' || struct.schema == null || typeof x !== 'object' || x == null) {\n      return x;\n    } else {\n      const ret = {};\n\n      for (const key in struct.schema) {\n        if (key in x) {\n          ret[key] = x[key];\n        }\n      }\n\n      return ret;\n    }\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction mask(value, struct) {\n  const M = masked(struct);\n  const ret = create(value, M);\n  return ret;\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  const expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', value => {\n    if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return size === 0 || expected + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min, max = min) {\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\nexport { Struct, StructError, any, array, assert, assign, boolean, coerce, create, date, defaulted, define, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, masked, max, min, never, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.es.js.map\n","export default (paths: (string | number)[]): string =>\n  paths\n    .reduce(\n      (previous, path: string | number, index): string =>\n        `${previous}${\n          typeof path === 'string'\n            ? `${index > 0 ? '.' : ''}${path}`\n            : `[${path}]`\n        }`,\n      '',\n    )\n    .toString();\n","import {\n  appendErrors,\n  transformToNestObject,\n  Resolver,\n  ResolverSuccess,\n  ResolverError,\n} from 'react-hook-form';\nimport { StructError, validate, Struct, Infer } from 'superstruct';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: StructError,\n  validateAllFieldCriteria: boolean,\n) =>\n  error\n    .failures()\n    .reduce((previous: Record<string, any>, { path, message = '', type }) => {\n      const currentPath = convertArrayToPathName(path);\n      return {\n        ...previous,\n        ...(path\n          ? previous[currentPath] && validateAllFieldCriteria\n            ? {\n                [currentPath]: appendErrors(\n                  currentPath,\n                  validateAllFieldCriteria,\n                  previous,\n                  type || '',\n                  message,\n                ),\n              }\n            : {\n                [currentPath]: previous[currentPath] || {\n                  message,\n                  type,\n                  ...(validateAllFieldCriteria\n                    ? {\n                        types: { [type || '']: message || true },\n                      }\n                    : {}),\n                },\n              }\n          : {}),\n      };\n    }, {});\n\ntype Options = Parameters<typeof validate>[2];\n\nexport const superstructResolver = <T extends Struct<any, any>>(\n  schema: T,\n  options?: Options,\n): Resolver<Infer<T>> => (values, _, validateAllFieldCriteria = false) => {\n  const [errors, result] = validate(values, schema, options);\n\n  if (errors != null) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(errors, validateAllFieldCriteria),\n      ),\n    } as ResolverError<Infer<T>>;\n  }\n\n  return {\n    values: result,\n    errors: {},\n  } as ResolverSuccess<Infer<T>>;\n};\n","import {\n  appendErrors,\n  transformToNestObject,\n  Resolver,\n  FieldValues,\n} from 'react-hook-form';\nimport * as Joi from 'joi';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: Joi.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.details)\n    ? error.details.reduce(\n        (previous: Record<string, any>, { path, message = '', type }) => {\n          const currentPath = convertArrayToPathName(path);\n\n          return {\n            ...previous,\n            ...(path\n              ? previous[currentPath] && validateAllFieldCriteria\n                ? {\n                    [currentPath]: appendErrors(\n                      currentPath,\n                      validateAllFieldCriteria,\n                      previous,\n                      type,\n                      message,\n                    ),\n                  }\n                : {\n                    [currentPath]: previous[currentPath] || {\n                      message,\n                      type,\n                      ...(validateAllFieldCriteria\n                        ? {\n                            types: { [type]: message || true },\n                          }\n                        : {}),\n                    },\n                  }\n              : {}),\n          };\n        },\n        {},\n      )\n    : [];\n\nexport const joiResolver = <TFieldValues extends FieldValues>(\n  schema: Joi.Schema,\n  options: Joi.AsyncValidationOptions = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    return {\n      values: await schema.validateAsync(values, {\n        ...options,\n      }),\n      errors: {},\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(e, validateAllFieldCriteria),\n      ),\n    };\n  }\n};\n","import {\n  appendErrors,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  transformToNestObject,\n} from 'react-hook-form';\nimport * as z from 'zod';\nimport { ParseParams } from 'zod/lib/src/parser';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  zodError: z.ZodError,\n  validateAllFieldCriteria: boolean,\n) => {\n  if (zodError.isEmpty) {\n    return {};\n  }\n\n  return zodError.errors.reduce<Record<string, any>>(\n    (previous, { path, message, code: type }) => {\n      const currentPath = convertArrayToPathName(path);\n\n      return {\n        ...previous,\n        ...(path\n          ? previous[currentPath] && validateAllFieldCriteria\n            ? {\n                [currentPath]: appendErrors(\n                  currentPath,\n                  validateAllFieldCriteria,\n                  previous,\n                  type,\n                  message,\n                ),\n              }\n            : {\n                [currentPath]: previous[currentPath] || {\n                  message,\n                  type,\n                  ...(validateAllFieldCriteria\n                    ? {\n                        types: { [type]: message || true },\n                      }\n                    : {}),\n                },\n              }\n          : {}),\n      };\n    },\n    {},\n  );\n};\n\nexport const zodResolver = <T extends z.ZodSchema<any, any>>(\n  schema: T,\n  options?: ParseParams,\n): Resolver<z.infer<T>> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  const result = schema.safeParse(values, options);\n\n  if (result.success) {\n    return { values: result.data, errors: {} } as ResolverSuccess<z.infer<T>>;\n  }\n\n  return {\n    values: {},\n    errors: transformToNestObject(\n      parseErrorSchema(result.error, validateAllFieldCriteria),\n    ),\n  } as ResolverError<z.infer<T>>;\n};\n","import { FieldValues, Resolver, transformToNestObject } from 'react-hook-form';\nimport * as Vest from 'vest';\n\ntype VestErrors = Record<string, string[]>;\n\ntype ICreateResult = ReturnType<typeof Vest.create>;\n\ntype Promisify = <T extends ICreateResult, K>(\n  fn: T,\n) => (args: K) => Promise<Vest.IVestResult>;\n\nconst promisify: Promisify = (validatorFn) => (...args) =>\n  new Promise((resolve) => validatorFn(...args).done(resolve as Vest.DoneCB));\n\nconst parseErrorSchema = (\n  vestError: VestErrors,\n  validateAllFieldCriteria: boolean,\n) => {\n  return Object.entries(vestError).reduce((prev, [key, value]) => {\n    return {\n      ...prev,\n      [key]: {\n        type: '',\n        message: value[0],\n        ...(validateAllFieldCriteria\n          ? {\n              types: value.reduce((prev, message, index) => {\n                return {\n                  ...prev,\n                  [index]: message,\n                };\n              }, {}),\n            }\n          : {}),\n      },\n    };\n  }, {});\n};\n\nexport const vestResolver = <TFieldValues extends FieldValues>(\n  schema: ICreateResult,\n  _: any = {},\n  validateAllFieldCriteria = false,\n): Resolver<TFieldValues> => async (values) => {\n  const validateSchema = promisify(schema);\n  const result = await validateSchema(values);\n  const errors = result.getErrors();\n\n  if (!result.hasErrors()) {\n    return { values: values as any, errors: {} };\n  }\n\n  return {\n    values: {},\n    errors: transformToNestObject(\n      parseErrorSchema(errors, validateAllFieldCriteria),\n    ),\n  };\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport {\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  transformToNestObject,\n} from 'react-hook-form';\nimport Yup from 'yup';\n\n/**\n * From 0.32.0, Yup add TypeScript support and `path` typing is optional that's why we have `@ts-expect-error`\n * FYI: `path`: a string, indicating where there error was thrown. `path` is empty at the root level.\n * react-hook-form's values are object so path is defined\n * https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n */\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) => {\n  return Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          // @ts-expect-error\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          const key = path || type;\n\n          return {\n            ...previous,\n            ...(key\n              ? {\n                  [key]: {\n                    ...(previous[key] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            // @ts-expect-error\n                            [type]: previousTypes[type]\n                              ? // @ts-expect-error\n                                [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        // @ts-expect-error\n        [error.path]: { message: error.message, type: error.type },\n      };\n};\n\ntype ValidateOptions<T extends Yup.AnyObjectSchema> = Parameters<\n  T['validate']\n>[1];\n\nexport const yupResolver = <T extends Yup.AnyObjectSchema>(\n  schema: T,\n  options: ValidateOptions<T> = {\n    abortEarly: false,\n  },\n): Resolver<Yup.InferType<T>> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (options.context && process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: await schema.validate(values, {\n        ...options,\n        context,\n      }),\n      errors: {},\n    } as ResolverSuccess<Yup.InferType<T>>;\n  } catch (e) {\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: transformToNestObject(parsedErrors),\n    } as ResolverError<Yup.InferType<T>>;\n  }\n};\n"],"names":["StructError","TypeError","[object Object]","failure","failures","cached","message","rest","path","super","length","join","Object","assign","this","name","constructor","_cached","run","value","struct","options","branch","coerce","ctx","coercer","valid","validator","undefined","refiner","k","v","s","entries","ts","t","Map","set","Set","add","x","validate","tuples","tuple","input","done","next","shiftIterator","paths","reduce","previous","index","toString","parseErrorSchema","error","validateAllFieldCriteria","type","currentPath","convertArrayToPathName","appendErrors","types","Array","isArray","details","zodError","isEmpty","errors","code","vestError","prev","key","schema","abortEarly","async","values","_","validateAsync","e","transformToNestObject","result","validateSchema","validatorFn","args","Promise","resolve","getErrors","hasErrors","context","process","env","NODE_ENV","parsedErrors","inner","previousTypes","concat","safeParse","success","data"],"mappings":"6TAYA,MAAMA,UAAoBC,UACxBC,YAAYC,EAASC,GACnB,IAAIC,EACJ,MAAMC,QACJA,KACGC,GACDJ,GACEK,KACJA,GACEL,EAEJM,MAD4B,IAAhBD,EAAKE,OAAeJ,EAAU,YAAcE,EAAKG,KAAK,KAAO,OAASL,GAElFM,OAAOC,OAAOC,KAAMP,GACpBO,KAAKC,KAAOD,KAAKE,YAAYD,KAE7BD,KAAKV,SAAW,KACd,IAAIa,EAEJ,OAA6B,OAArBA,EAAUZ,GAAkBY,EAAUZ,EAAS,CAACF,KAAYC,OA8G1E,SAAUc,EAAIC,EAAOC,EAAQC,EAAU,IACrC,MAAMb,KACJA,EAAO,GAAEc,OACTA,EAAS,CAACH,GAAMI,OAChBA,GAAS,GACPF,EACEG,EAAM,CACVhB,KAAAA,EACAc,OAAAA,GAGEC,IACFJ,EAAQC,EAAOK,QAAQN,EAAOK,IAGhC,IAAIE,GAAQ,EAEZ,IAAK,MAAMvB,KAAWiB,EAAOO,UAAUR,EAAOK,GAC5CE,GAAQ,OACF,CAACvB,OAASyB,GAGlB,GAAIF,EACF,IAAK,MAAMvB,KAAWiB,EAAOS,QAAQV,EAAOK,GAC1CE,GAAQ,OACF,CAACvB,OAASyB,GAIpB,IAAK,IAAKE,EAAGC,EAAGC,KAAMZ,EAAOa,QAAQd,EAAOK,GAAM,CAChD,MAAMU,EAAKhB,EAAIa,EAAGC,EAAG,CACnBxB,UAAYoB,IAANE,EAAkBtB,EAAO,IAAIA,EAAMsB,GACzCR,YAAcM,IAANE,EAAkBR,EAAS,IAAIA,EAAQS,GAC/CR,OAAAA,IAGF,IAAK,MAAMY,KAAKD,EACVC,EAAE,IACJT,GAAQ,OACF,CAACS,EAAE,QAAIP,IACJL,IACTQ,EAAII,EAAE,QAEIP,IAANE,EACFX,EAAQY,EACCZ,aAAiBiB,IAC1BjB,EAAMkB,IAAIP,EAAGC,GACJZ,aAAiBmB,IAC1BnB,EAAMoB,IAAIR,GA5IE,iBADJS,EA8IUrB,IA7IW,MAALqB,IA8IxBrB,EAAMW,GAAKC,IA/IrB,IAAkBS,EAqJZd,SACI,MAACE,EAAWT,IA+uBtB,SAASsB,EAAStB,EAAOC,EAAQC,EAAU,IACzC,MAAMqB,EAASxB,EAAIC,EAAOC,EAAQC,GAC5BsB,EA52BR,SAAuBC,GACrB,MAAMC,KACJA,EAAI1B,MACJA,GACEyB,EAAME,OACV,OAAOD,OAAOjB,EAAYT,EAu2BZ4B,CAAcL,GAE5B,GAAIC,EAAM,GAAI,CAQZ,MAAO,CAPO,IAAI3C,EAAY2C,EAAM,IAAI,YACtC,IAAK,MAAMR,KAAKO,EACVP,EAAE,WACEA,EAAE,YAICP,GAGf,MAAO,MAACA,EADEe,EAAM,UCl8BJK,GACdA,EACGC,QACC,CAACC,EAAU1C,EAAuB2C,IAChC,GAAGD,IACe,iBAAT1C,EACH,GAAG2C,EAAQ,EAAI,IAAM,KAAK3C,IAC1B,IAAIA,QAEZ,IAED4C,WCDL,MAAMC,EAAmB,CACvBC,EACAC,IAEAD,EACGlD,WACA6C,QAAO,CAACC,GAAiC1C,KAAAA,EAAMF,QAAAA,EAAU,GAAIkD,KAAAA,MAC5D,MAAMC,EAAcC,EAAuBlD,GAC3C,sCACK0C,GACC1C,EACA0C,EAASO,IAAgBF,EACvB,CACErD,CAACuD,GAAcE,eACbF,EACAF,EACAL,EACAM,GAAQ,GACRlD,IAGJ,CACEJ,CAACuD,GAAcP,EAASO,mBACtBnD,QAAAA,EACAkD,KAAAA,GACID,EACA,CACEK,MAAO,CAAE1D,CAACsD,GAAQ,IAAKlD,IAAW,IAEpC,KAGV,MAEL,ICnCD+C,EAAmB,CACvBC,EACAC,IAEAM,MAAMC,QAAQR,EAAMS,SAChBT,EAAMS,QAAQd,QACZ,CAACC,GAAiC1C,KAAAA,EAAMF,QAAAA,EAAU,GAAIkD,KAAAA,MACpD,MAAMC,EAAcC,EAAuBlD,GAE3C,sCACK0C,GACC1C,EACA0C,EAASO,IAAgBF,EACvB,CACErD,CAACuD,GAAcE,eACbF,EACAF,EACAL,EACAM,EACAlD,IAGJ,CACEJ,CAACuD,GAAcP,EAASO,mBACtBnD,QAAAA,EACAkD,KAAAA,GACID,EACA,CACEK,MAAO,CAAE1D,CAACsD,GAAOlD,IAAW,IAE9B,KAGV,MAGR,IAEF,GCpCA+C,EAAmB,CACvBW,EACAT,IAEIS,EAASC,QACJ,GAGFD,EAASE,OAAOjB,QACrB,CAACC,GAAY1C,KAAAA,EAAMF,QAAAA,EAAS6D,KAAMX,MAChC,MAAMC,EAAcC,EAAuBlD,GAE3C,sCACK0C,GACC1C,EACA0C,EAASO,IAAgBF,EACvB,CACErD,CAACuD,GAAcE,eACbF,EACAF,EACAL,EACAM,EACAlD,IAGJ,CACEJ,CAACuD,GAAcP,EAASO,mBACtBnD,QAAAA,EACAkD,KAAAA,GACID,EACA,CACEK,MAAO,CAAE1D,CAACsD,GAAOlD,IAAW,IAE9B,KAGV,MAGR,ICpCE+C,EAAmB,CACvBe,EACAb,IAEO3C,OAAOqB,QAAQmC,GAAWnB,QAAO,CAACoB,GAAOC,EAAKnD,oCAE9CkD,IACHnE,CAACoE,kBACCd,KAAM,GACNlD,QAASa,EAAM,IACXoC,EACA,CACEK,MAAOzC,EAAM8B,QAAO,CAACoB,EAAM/D,EAAS6C,mCAE7BkB,IACHnE,CAACiD,GAAQ7C,KAEV,KAEL,OAGP,kBFasB,CACzBiE,EACAlD,EAAsC,CACpCmD,YAAY,KAEaC,MAC3BC,EACAC,EACApB,GAA2B,KAE3B,IACE,MAAO,CACLmB,aAAcH,EAAOK,cAAcF,mBAC9BrD,IAEL6C,OAAQ,IAEV,MAAOW,GACP,MAAO,CACLH,OAAQ,GACRR,OAAQY,wBACNzB,EAAiBwB,EAAGtB,6BDtBO,CACjCgB,EACAlD,IACuB,CAACqD,EAAQC,EAAGpB,GAA2B,KAC9D,MAAOW,EAAQa,GAAUtC,EAASiC,EAAQH,EAAQlD,GAElD,OAAc,MAAV6C,EACK,CACLQ,OAAQ,GACRR,OAAQY,wBACNzB,EAAiBa,EAAQX,KAKxB,CACLmB,OAAQK,EACRb,OAAQ,oBG1BgB,CAC1BK,EACAI,EAAS,GACTpB,GAA2B,IACAkB,MAAOC,IAClC,MAAMM,GAjCsBC,EAiCKV,EAjCW,IAAIW,IAChD,IAAIC,SAASC,GAAYH,KAAeC,GAAMrC,KAAKuC,MADxB,IAACH,EAkC5B,MAAMF,QAAeC,EAAeN,GAC9BR,EAASa,EAAOM,YAEtB,OAAKN,EAAOO,YAIL,CACLZ,OAAQ,GACRR,OAAQY,wBACNzB,EAAiBa,EAAQX,KANpB,CAAEmB,OAAQA,EAAeR,OAAQ,mBCejB,CACzBK,EACAlD,EAA8B,CAC5BmD,YAAY,KAEiBC,MAC/BC,EACAa,EACAhC,GAA2B,KAE3B,IAOE,OANIlC,EAAQkE,SAAWC,QAAQC,IAAIC,SAM5B,CACLhB,aAAcH,EAAO9B,SAASiC,iCACzBrD,IACHkE,QAAAA,KAEFrB,OAAQ,IAEV,MAAOW,GACP,MAAMc,EA1Ee,EACvBrC,EACAC,IAEOM,MAAMC,QAAQR,EAAMsC,QAAUtC,EAAMsC,MAAMlF,OAC7C4C,EAAMsC,MAAM3C,QACV,CAACC,GAAiC1C,KAAAA,EAAMF,QAAAA,EAASkD,KAAAA,MAE/C,MAAMqC,EAAiB3C,EAAS1C,IAAS0C,EAAS1C,GAAMoD,OAAU,GAC5DU,EAAM9D,GAAQgD,EAEpB,sCACKN,GACCoB,EACA,CACEpE,CAACoE,kCACKpB,EAASoB,IAAQ,CACnBhE,QAAAA,EACAkD,KAAAA,IAEED,EACA,CACEK,qCACKiC,IAEH3F,CAACsD,GAAOqC,EAAcrC,GAElB,IAAI,GAAGsC,OAAOD,EAAcrC,IAAQlD,GACpCA,KAGR,KAGR,MAGR,IAEF,CAEEJ,CAACoD,EAAM9C,MAAO,CAAEF,QAASgD,EAAMhD,QAASkD,KAAMF,EAAME,OAiCnCH,CAAiBwB,EAAGtB,GACzC,MAAO,CACLmB,OAAQ,GACRR,OAAQY,wBAAsBa,oBFtCT,CACzBpB,EACAlD,IACyBoD,MACzBC,EACAC,EACApB,GAA2B,KAE3B,MAAMwB,EAASR,EAAOwB,UAAUrB,EAAQrD,GAExC,OAAI0D,EAAOiB,QACF,CAAEtB,OAAQK,EAAOkB,KAAM/B,OAAQ,IAGjC,CACLQ,OAAQ,GACRR,OAAQY,wBACNzB,EAAiB0B,EAAOzB,MAAOC"}