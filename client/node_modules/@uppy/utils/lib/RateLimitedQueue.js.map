{"version":3,"sources":["RateLimitedQueue.js"],"names":["createCancelError","Error","RateLimitedQueue","constructor","limit","Infinity","run","fn","queueOptions","wrapPromiseFunction","args","queuedRequest","outerPromise","Promise","resolve","reject","cancelError","innerPromise","err","then","result","done","abort","cancelActive","queueMicrotask","length","next","shift","handler","options","priority","index","findIndex","other","push","splice","indexOf","module","exports","internalRateLimitedQueue","Symbol"],"mappings":"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","sourcesContent":["function createCancelError () {\n  return new Error('Cancelled')\n}\n\nclass RateLimitedQueue {\n  #activeRequests = 0\n\n  #queuedHandlers = []\n\n  constructor (limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity\n    } else {\n      this.limit = limit\n    }\n  }\n\n  #call (fn) {\n    this.#activeRequests += 1\n\n    let done = false\n\n    let cancelActive\n    try {\n      cancelActive = fn()\n    } catch (err) {\n      this.#activeRequests -= 1\n      throw err\n    }\n\n    return {\n      abort: () => {\n        if (done) return\n        done = true\n        this.#activeRequests -= 1\n        cancelActive()\n        this.#queueNext()\n      },\n\n      done: () => {\n        if (done) return\n        done = true\n        this.#activeRequests -= 1\n        this.#queueNext()\n      },\n    }\n  }\n\n  #queueNext () {\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    queueMicrotask(() => this.#next())\n  }\n\n  #next () {\n    if (this.#activeRequests >= this.limit) {\n      return\n    }\n    if (this.#queuedHandlers.length === 0) {\n      return\n    }\n\n    // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n    const next = this.#queuedHandlers.shift()\n    const handler = this.#call(next.fn)\n    next.abort = handler.abort\n    next.done = handler.done\n  }\n\n  #queue (fn, options = {}) {\n    const handler = {\n      fn,\n      priority: options.priority || 0,\n      abort: () => {\n        this.#dequeue(handler)\n      },\n      done: () => {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug')\n      },\n    }\n\n    const index = this.#queuedHandlers.findIndex((other) => {\n      return handler.priority > other.priority\n    })\n    if (index === -1) {\n      this.#queuedHandlers.push(handler)\n    } else {\n      this.#queuedHandlers.splice(index, 0, handler)\n    }\n    return handler\n  }\n\n  #dequeue (handler) {\n    const index = this.#queuedHandlers.indexOf(handler)\n    if (index !== -1) {\n      this.#queuedHandlers.splice(index, 1)\n    }\n  }\n\n  run (fn, queueOptions) {\n    if (this.#activeRequests < this.limit) {\n      return this.#call(fn)\n    }\n    return this.#queue(fn, queueOptions)\n  }\n\n  wrapPromiseFunction (fn, queueOptions) {\n    return (...args) => {\n      let queuedRequest\n      const outerPromise = new Promise((resolve, reject) => {\n        queuedRequest = this.run(() => {\n          let cancelError\n          let innerPromise\n          try {\n            innerPromise = Promise.resolve(fn(...args))\n          } catch (err) {\n            innerPromise = Promise.reject(err)\n          }\n\n          innerPromise.then((result) => {\n            if (cancelError) {\n              reject(cancelError)\n            } else {\n              queuedRequest.done()\n              resolve(result)\n            }\n          }, (err) => {\n            if (cancelError) {\n              reject(cancelError)\n            } else {\n              queuedRequest.done()\n              reject(err)\n            }\n          })\n\n          return () => {\n            cancelError = createCancelError()\n          }\n        }, queueOptions)\n      })\n\n      outerPromise.abort = () => {\n        queuedRequest.abort()\n      }\n\n      return outerPromise\n    }\n  }\n}\n\nmodule.exports = {\n  RateLimitedQueue,\n  internalRateLimitedQueue: Symbol('__queue'),\n}\n"]}